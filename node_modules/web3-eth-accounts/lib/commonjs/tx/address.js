"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Address = void 0;
/*
This file is part of web3.js.

web3.js is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

web3.js is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
const secp256k1_1 = require("ethereum-cryptography/secp256k1");
const keccak_1 = require("ethereum-cryptography/keccak");
const utils_1 = require("../common/utils");
class Address {
    constructor(buf) {
        if (buf.length !== 20) {
            throw new Error('Invalid address length');
        }
        this.buf = buf;
    }
    /**
     * Returns the zero address.
     */
    static zero() {
        return new Address((0, utils_1.zeros)(20));
    }
    /**
     * Is address equal to another.
     */
    equals(address) {
        return this.buf.equals(address.buf);
    }
    /**
     * Is address zero.
     */
    isZero() {
        return this.equals(Address.zero());
    }
    /**
     * Returns hex encoding of address.
     */
    toString() {
        return `0x${this.buf.toString('hex')}`;
    }
    /**
     * Returns Buffer representation of address.
     */
    toBuffer() {
        return Buffer.from(this.buf);
    }
    /**
     * Returns the ethereum address of a given public key.
     * Accepts "Ethereum public keys" and SEC1 encoded keys.
     * @param pubKey The two points of an uncompressed key, unless sanitize is enabled
     * @param sanitize Accept public keys in other formats
     */
    static publicToAddress(_pubKey, sanitize = false) {
        let pubKey = _pubKey;
        (0, utils_1.assertIsBuffer)(pubKey);
        if (sanitize && pubKey.length !== 64) {
            pubKey = Buffer.from(secp256k1_1.Point.fromHex(pubKey).toRawBytes(false).slice(1));
        }
        if (pubKey.length !== 64) {
            throw new Error('Expected pubKey to be of length 64');
        }
        // Only take the lower 160bits of the hash
        // eslint-disable-next-line deprecation/deprecation
        return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);
    }
}
exports.Address = Address;
//# sourceMappingURL=address.js.map