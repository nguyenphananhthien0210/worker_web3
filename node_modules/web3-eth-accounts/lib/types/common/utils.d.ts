/// <reference types="node" />
import { NestedBufferArray, ToBufferInputTypes, TypeOutput, TypeOutputReturnType, NestedUint8Array } from './types';
declare type ConfigHardfork = {
    name: string;
    block: null;
    timestamp: number;
} | {
    name: string;
    block: number;
    timestamp?: number;
};
/**
 * Removes '0x' from a given `String` if present
 * @param str the string value
 * @returns the string without 0x prefix
 */
export declare const stripHexPrefix: (str: string) => string;
/**
 * Parses a genesis.json exported from Geth into parameters for Common instance
 * @param json representing the Geth genesis file
 * @param name optional chain name
 * @returns parsed params
 */
export declare function parseGethGenesis(json: any, name?: string, mergeForkIdPostMerge?: boolean): {
    name: string;
    chainId: number;
    networkId: number;
    genesis: {
        timestamp: string;
        gasLimit: number;
        difficulty: number;
        nonce: string;
        extraData: string;
        mixHash: string;
        coinbase: string;
        baseFeePerGas: string;
    };
    hardfork: string | undefined;
    hardforks: ConfigHardfork[];
    bootstrapNodes: never[];
    consensus: {
        type: string;
        algorithm: string;
        clique: {
            period: any;
            epoch: any;
        };
        ethash?: undefined;
    } | {
        type: string;
        algorithm: string;
        ethash: {};
        clique?: undefined;
    };
};
/**
 * Pads a `String` to have an even length
 * @param value
 * @return output
 */
export declare function padToEven(value: string): string;
/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
export declare const intToBuffer: (i: number) => Buffer;
/**
 * Attempts to turn a value into a `Buffer`.
 * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BigInt` and other objects
 * with a `toArray()` or `toBuffer()` method.
 * @param v the value
 */
export declare const toBuffer: (v: ToBufferInputTypes) => Buffer;
/**
 * Converts a `Buffer` into a `0x`-prefixed hex `String`.
 * @param buf `Buffer` object to convert
 */
export declare const bufferToHex: (_buf: Buffer) => string;
/**
 * Converts a {@link Buffer} to a {@link bigint}
 */
export declare function bufferToBigInt(buf: Buffer): bigint;
/**
 * Converts a {@link bigint} to a {@link Buffer}
 */
export declare function bigIntToBuffer(num: bigint): Buffer;
/**
 * Returns a buffer filled with 0s.
 * @param bytes the number of bytes the buffer should be
 */
export declare const zeros: (bytes: number) => Buffer;
/**
 * Throws if input is not a buffer
 * @param {Buffer} input value to check
 */
export declare const assertIsBuffer: (input: Buffer) => void;
/**
 * Left Pads a `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param msg the value to pad (Buffer)
 * @param length the number of bytes the output should be
 * @return (Buffer)
 */
export declare const setLengthLeft: (msg: Buffer, length: number) => Buffer;
/**
 * Trims leading zeros from a `Buffer`.
 * @param a (Buffer)
 * @return (Buffer)
 */
export declare const unpadBuffer: (a: Buffer) => Buffer;
/**
 * Converts a {@link Uint8Array} or {@link NestedUint8Array} to {@link Buffer} or {@link NestedBufferArray}
 */
export declare function arrToBufArr(arr: Uint8Array): Buffer;
export declare function arrToBufArr(arr: NestedUint8Array): NestedBufferArray;
export declare function arrToBufArr(arr: Uint8Array | NestedUint8Array): Buffer | NestedBufferArray;
/**
 * Converts a {@link bigint} to a `0x` prefixed hex string
 */
export declare const bigIntToHex: (num: bigint) => string;
/**
 * Convert value from bigint to an unpadded Buffer
 * (useful for RLP transport)
 * @param value value to convert
 */
export declare function bigIntToUnpaddedBuffer(value: bigint): Buffer;
/**
 * Converts a {@link Buffer} or {@link NestedBufferArray} to {@link Uint8Array} or {@link NestedUint8Array}
 */
export declare function bufArrToArr(arr: Buffer): Uint8Array;
export declare function bufArrToArr(arr: NestedBufferArray): NestedUint8Array;
export declare function bufArrToArr(arr: Buffer | NestedBufferArray): Uint8Array | NestedUint8Array;
/**
 * ECDSA public key recovery from signature.
 * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions
 * @returns Recovered public key
 */
export declare const ecrecover: (msgHash: Buffer, v: bigint, r: Buffer, s: Buffer, chainId?: bigint) => Buffer;
/**
 * Convert an input to a specified type.
 * Input of null/undefined returns null/undefined regardless of the output type.
 * @param input value to convert
 * @param outputType type to output
 */
export declare function toType<T extends TypeOutput>(input: null, outputType: T): null;
export declare function toType<T extends TypeOutput>(input: undefined, outputType: T): undefined;
export declare function toType<T extends TypeOutput>(input: ToBufferInputTypes, outputType: T): TypeOutputReturnType[T];
export {};
//# sourceMappingURL=utils.d.ts.map